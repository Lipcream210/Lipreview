<!DOCTYPE html>
<html>
<head>
    <title>Review</title>
    <style>
        /* [Previous CSS styles remain exactly the same] */
    </style>
</head>
<body>
    <!-- [Previous HTML structure remains exactly the same] -->

    <script>
        // Global variables
        let questions = JSON.parse(localStorage.getItem("questions")) || {};
        let currentSubject = "";
        let currentQuestionIndex = 0;
        let score = 0;
        let shuffledQuestions = [];
        let currentQuestionData = null;
        let lastSyncTime = localStorage.getItem("lastSyncTime") || 0;

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', async function() {
            // Try to sync with cloud immediately
            await syncWithCloud();
            displayQuestions();
        });

        // [Previous showTab, loadSubject, resetQuiz functions remain the same]

        async function showQuestion() {
            currentQuestionData = shuffledQuestions[currentQuestionIndex];
            document.getElementById("question").innerText = currentQuestionData.question;
            document.getElementById("question-counter").innerText = `${currentQuestionIndex + 1}/${shuffledQuestions.length}`;
            
            let optionsDiv = document.getElementById("options");
            optionsDiv.innerHTML = "";
            
            // Prepare options with their labels
            const optionsWithLetters = [
                { letter: "A", text: currentQuestionData.option1 },
                { letter: "B", text: currentQuestionData.option2 },
                { letter: "C", text: currentQuestionData.option3 },
                { letter: "D", text: currentQuestionData.option4 }
            ].filter(opt => opt.text); // Remove empty options
            
            // Find the correct answer text
            const correctAnswerLetter = currentQuestionData['correct-answer'];
            const correctAnswerText = optionsWithLetters.find(opt => opt.letter === correctAnswerLetter)?.text;
            
            // Shuffle the options
            shuffleArray(optionsWithLetters);
            
            // Create buttons for each option
            optionsWithLetters.forEach(option => {
                let button = document.createElement("button");
                button.innerText = `${option.letter}. ${option.text}`;
                
                // Check if this option is the correct one (comparing text)
                const isCorrect = option.text === correctAnswerText;
                
                button.onclick = () => checkAnswer(button, option.letter, correctAnswerLetter, isCorrect);
                optionsDiv.appendChild(button);
            });
        }

        // [Previous checkAnswer, nextQuestion functions remain the same]

        async function addQuestion() {
            const subject = document.getElementById("add-subject").value;
            const question = document.getElementById("new-question").value.trim();
            const option1 = document.getElementById("option1").value.trim();
            const option2 = document.getElementById("option2").value.trim();
            const option3 = document.getElementById("option3").value.trim();
            const option4 = document.getElementById("option4").value.trim();
            const correctAnswer = document.getElementById("correct-answer").value;

            // Validate inputs
            if (!subject || !question || !correctAnswer || !option1 || !option2) {
                updateSyncStatus("Please fill all required fields", "error");
                return;
            }

            const questionData = {
                subject,
                question,
                option1,
                option2,
                option3: option3 || undefined,
                option4: option4 || undefined,
                'correct-answer': correctAnswer,
                timestamp: Date.now()
            };

            // 1. First save to localStorage for immediate response
            if (!questions[subject]) questions[subject] = [];
            questions[subject].push(questionData);
            localStorage.setItem("questions", JSON.stringify(questions));
            
            // 2. Then try to save to cloud
            try {
                updateSyncStatus("Saving to cloud...", "info");
                const response = await fetch('/.netlify/functions/save-question', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(questionData)
                });
                
                if (!response.ok) throw new Error('Failed to save');
                
                updateSyncStatus("Question saved to cloud!", "success");
                lastSyncTime = Date.now();
                localStorage.setItem("lastSyncTime", lastSyncTime);
            } catch (error) {
                console.error('Cloud save failed:', error);
                updateSyncStatus("Saved locally (will sync later)", "error");
            }
            
            displayQuestions();
            document.getElementById("question-form").reset();
        }

        async function syncWithCloud() {
            try {
                updateSyncStatus("Syncing with cloud...", "info");
                const response = await fetch('/.netlify/functions/get-questions');
                
                if (!response.ok) throw new Error('Failed to load cloud questions');
                
                const cloudQuestions = await response.json();
                
                // Merge cloud questions with local ones
                for (const subject in cloudQuestions) {
                    if (!questions[subject]) questions[subject] = [];
                    
                    cloudQuestions[subject].forEach(cloudQ => {
                        const exists = questions[subject].some(localQ => 
                            localQ.timestamp === cloudQ.timestamp
                        );
                        if (!exists) questions[subject].push(cloudQ);
                    });
                }
                
                localStorage.setItem("questions", JSON.stringify(questions));
                lastSyncTime = Date.now();
                localStorage.setItem("lastSyncTime", lastSyncTime);
                updateSyncStatus("Sync complete!", "success");
            } catch (error) {
                console.error('Sync failed:', error);
                updateSyncStatus("Sync failed. Using local data.", "error");
            }
        }

        // [Previous displayQuestions, deleteQuestion, editQuestion functions remain the same]

        function updateSyncStatus(message, type) {
            const statusEl = document.getElementById('sync-status');
            statusEl.textContent = message;
            statusEl.className = `sync-status sync-${type}`;
            statusEl.classList.remove("hidden");
            setTimeout(() => statusEl.classList.add("hidden"), 3000);
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }
    </script>
</body>
</html>